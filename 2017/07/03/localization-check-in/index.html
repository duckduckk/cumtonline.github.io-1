<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="不敢开车的老司机"/>




  <meta name="keywords" content="转载," />





  <link rel="alternate" href="/default" title="中国矿业大学学生在线">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://cumtonline.github.io/2017/07/03/localization-check-in/"/>


<meta name="description" content="写在前面  本文由工作室08级学长dozer创作   不敢开车的老司机 常说车开多了胆子会越来越小，写代码也是。其实不是老司机胆子小了，而是新手无知无畏罢了。 最近一个很简单的功能，我做了2-3天，要是在我刚毕业的是时候把这个任务交给我，啪啪啪，不是我吹牛，2-3小时我就搞定了！ 直接看产出的结果可能没觉得怎么样，甚至还会觉得这么做不对，但我觉得其中的思考过程还是非常有价值的，所以想在这记录下来">
<meta name="keywords" content="转载">
<meta property="og:type" content="article">
<meta property="og:title" content="不敢开车的老司机">
<meta property="og:url" content="http://cumtonline.github.io/2017/07/03/localization-check-in/index.html">
<meta property="og:site_name" content="中国矿业大学学生在线">
<meta property="og:description" content="写在前面  本文由工作室08级学长dozer创作   不敢开车的老司机 常说车开多了胆子会越来越小，写代码也是。其实不是老司机胆子小了，而是新手无知无畏罢了。 最近一个很简单的功能，我做了2-3天，要是在我刚毕业的是时候把这个任务交给我，啪啪啪，不是我吹牛，2-3小时我就搞定了！ 直接看产出的结果可能没觉得怎么样，甚至还会觉得这么做不对，但我觉得其中的思考过程还是非常有价值的，所以想在这记录下来">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-26T18:43:01.900Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不敢开车的老司机">
<meta name="twitter:description" content="写在前面  本文由工作室08级学长dozer创作   不敢开车的老司机 常说车开多了胆子会越来越小，写代码也是。其实不是老司机胆子小了，而是新手无知无畏罢了。 最近一个很简单的功能，我做了2-3天，要是在我刚毕业的是时候把这个任务交给我，啪啪啪，不是我吹牛，2-3小时我就搞定了！ 直接看产出的结果可能没觉得怎么样，甚至还会觉得这么做不对，但我觉得其中的思考过程还是非常有价值的，所以想在这记录下来">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?60efd223d1a759d774d495ebe182c9ff";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




    <title> 不敢开车的老司机 - 中国矿业大学学生在线 </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo"><img src="https://s1.ax1x.com/2017/12/29/z06uF.png"></a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                文章
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                关于
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/friends">
                            
                            
                                友链
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/search">
                            
                            
                                站内搜索
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>
      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          不敢开车的老司机
        
      </h1>

      <time class="post-time">
          7月 03 2017
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="写在前面"><a href="#写在前面" class="headerlink" title=" 写在前面 "></a><strong> 写在前面 </strong></h3><p><strong> 本文由工作室08级学长<a href="https://www.dozer.cc/" target="_blank" rel="noopener">dozer</a>创作 </strong></p>
<h3 id="不敢开车的老司机"><a href="#不敢开车的老司机" class="headerlink" title=" 不敢开车的老司机 "></a><strong> 不敢开车的老司机 </strong></h3><p>常说车开多了胆子会越来越小，写代码也是。其实不是老司机胆子小了，而是新手无知无畏罢了。</p>
<p>最近一个很简单的功能，我做了2-3天，要是在我刚毕业的是时候把这个任务交给我，啪啪啪，不是我吹牛，2-3小时我就搞定了！</p>
<p>直接看产出的结果可能没觉得怎么样，甚至还会觉得这么做不对，但我觉得其中的思考过程还是非常有价值的，所以想在这记录下来。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title=" 需求 "></a><strong> 需求 </strong></h3><p>这个任务的需求简单到一句话就可以描述了：做一个每日签到系统，连续签到会有额外的积分奖励。</p>
<p>这功能，见的太多了吧？我分分钟就把表结构和 API 设计好了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field                  | Type             | Null | Key | Default | Extra |</span><br><span class="line">+------------------------+------------------+------+-----+---------+-------+</span><br><span class="line">| user_id                | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| check_in_time          | timestamp        | NO   | PRI | NULL    |       |</span><br><span class="line">+------------------------+------------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure>
<p>API 就不用说了吧？太简单了，每次签到的时候检查一下当天有没有签到过就行了。</p>
<p>你看吧，我就说交给刚毕业的我，2-3小时就搞定了。</p>
<p>但真的这么简单吗？老司机一眼就看出了其中的各种问题！</p>
<p>1.时区问题：我们的 App 是一个国际化的 App，如何处理时区问题？<br>2.高并发问题：高并发的情况下会不会出现一天签到多次的问题？如何解决？<br>3.性能问题：需求中需要知道连续签到天数，按照这样的表结构如何查询才能最高效？</p>
<p>问题都列在这了，开始一个个解决吧。</p>
<h3 id="时区问题"><a href="#时区问题" class="headerlink" title=" 时区问题 "></a><strong> 时区问题 </strong></h3><p>第一个要面临的就是时区问题。</p>
<p>考虑不周的情况下，很多人会直接用当地时间或者 UTC 时间来解决。</p>
<p>因为如果在国内做开发，可能你的系统只要处理中国标准时间就够了，完全不需要考虑时区问题。</p>
<p>遥想当年做系统的时候，数据库里存的全部是本地时间… But it works well!</p>
<h4 id="签到的体验应该是怎么样的？"><a href="#签到的体验应该是怎么样的？" class="headerlink" title=" 签到的体验应该是怎么样的？"></a><strong> 签到的体验应该是怎么样的？</strong></h4><p>在国际化的背景下，签到的体验应该是怎么样的？</p>
<p>如果一个人一辈子呆在一个地方，那么他每日签到的时候就应该用他的当地时间作为节点。每天过午夜0点的时候，就可以再次签到了。</p>
<p>解决这点很简单啊！我们在签到的接口中，加入了<code>timezone</code>参数。<code>timezone</code>的最小颗粒度是分钟，所以我们的参数是分钟级别的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_now = utc_now + timezone * 60</span><br><span class="line">local_today_start = local_now - local_now % (24 * 60 * 60)</span><br><span class="line">local_today_start_in_utc = local_today_start - timezone * 60</span><br></pre></td></tr></table></figure>
<p>上述代码会根据用户传入的时区，找到他的时区中对应的一天开始时间。</p>
<p>然后 SQL 语句可以是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> check_in <span class="keyword">WHERE</span> user_id = &#123;user_id&#125; <span class="keyword">AND</span> check_in_time &gt;= &#123;local_today_start_in_utc&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以判断这个用户是不是在“今天”签到过了。</p>
<h3 id="恶意重复签到和高并发下的重复签到问题"><a href="#恶意重复签到和高并发下的重复签到问题" class="headerlink" title=" 恶意重复签到和高并发下的重复签到问题 "></a><strong> 恶意重复签到和高并发下的重复签到问题 </strong></h3><p>上面的方案看似完美，但是眼尖的老司机们又发现了问题！</p>
<p><code>utc_now</code>是系统时间，用户无法篡改，但<code>timezone</code>是用户传上来的，它完全可以伪造请求或者手动修改手机时区，服务器根本不可能判断这个参数是否真实。</p>
<p>那么就会出现如下场景：</p>
<p>用户<code>timezone</code>是<code>+480</code>，他在当地时间<code>2016-10-25 00:00:01</code>签到，相当于在在 UTC 时间<code>2016-10-24 16:00:01</code>签到。</p>
<p>此时，用户强制修改自己的时区为<code>+540</code>，在当地时间<code>2016-10-25 00:01:02</code>签到，相当于在在 UTC 时间<code>2016-10-24 17:00:02</code>签到。</p>
<p>根据上面的设计，用户是可以签到成功的，他可以利用这个方式，每天签到多次，这样也就可以获得大量的积分。系统统计连续签到天数的时候，也会出现错乱。</p>
<p>不仅如此，如果用户恶意快速请求接口，2次请求同时判断当天无签到，然后又同时写入了数据，也会出现重复签到问题。</p>
<h4 id="少用事务，多用唯一键索引"><a href="#少用事务，多用唯一键索引" class="headerlink" title=" 少用事务，多用唯一键索引 "></a><strong> 少用事务，多用唯一键索引 </strong></h4><p>如何解决这两个问题呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  | UTC 10-25 | UTC 10-26 | UTC 10-27 |</span><br><span class="line"><span class="comment">---+-----------+-----------+-----------+---</span></span><br><span class="line">         | LOC 10-26 |</span><br></pre></td></tr></table></figure>
<p>先画个时间轴看看，假设用户的时区是 +12，那么他比 UTC 时间早了12个小时。</p>
<p>此时，他的一天中可能会对应到 UTC 时间的10月25日，也可能会对应到UTC时间的10月26日。</p>
<p>想要避免他重复签到，最理想的就是利用数据库唯一键索引或者是主键。那这里的联合主键其实就是用户 ID 和 UTC 日期了。</p>
<p>UTC 日期计算方法就是：<code>int(utc_now/24/60/60)</code>，也就是说，当地日期可能会跨2个UTC日期，那么默认取前一个。</p>
<p>表结构也要改一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">------------------------+------------------+------+-----+---------+-------+</span></span><br><span class="line">| Field                  | Type             | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">------------------------+------------------+------+-----+---------+-------+</span></span><br><span class="line">| user_id                | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| check_in_date          | timestamp        | NO   | PRI | NULL    |       |</span><br><span class="line">| check_in_time          | timestamp        | NO   |     | NULL    |       |</span><br><span class="line">+<span class="comment">------------------------+------------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure>
<p>这里加了一个<code>check_in_date</code>字段，并且，把<code>user_id</code>和<code>check_in_date</code>做成了联合主键。</p>
<p>这样无论用户怎么高并发，配合<code>INSERT IGNORE</code>语句，并在每次执行的时候检查影响行数，就可以知道是否插入成功了。</p>
<p>插入成功后再去增加积分就可以了。</p>
<h4 id="忘了时区问题？"><a href="#忘了时区问题？" class="headerlink" title=" 忘了时区问题？"></a><strong> 忘了时区问题？</strong></h4><p>等等，时区问题是不是漏了？</p>
<p>刚才说，如果一个用户瞬间到了另一个地方，时区变了一点点，理论上他是可以再度过一次0点的。</p>
<p>当地日期可能会跨2个 UTC 日期，那么默认取前一个。如果，发现他垮了时区，在当前时区下的“今天”没签到过，那么允许他再一次签到，写入数据库的就是跨2个 UTC 日期的后一个。</p>
<p>直接说太生涩，举个例子：</p>
<p>用户<code>timezone</code>是<code>+480</code>，他在当地时间<code>2016-10-25 00:00:01</code>签到，相当于在在 UTC 时间<code>2016-10-24 16:00:01</code>签到。</p>
<p>写入的数据是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br><span class="line">| user_id | check_in_date | check_in_time       |</span><br><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br><span class="line">| 1       | 2016-10-24    | 2016-10-24 16:00:01 |</span><br><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br></pre></td></tr></table></figure>
<p>接下来，他改时区了：</p>
<p>用户强制修改自己的时区为<code>+540</code>，在当地时间<code>2016-10-25 00:01:02</code>签到，相当于在在 UTC 时间<code>2016-10-24 17:00:02</code>签到。</p>
<p>根据这条 SQL 语句，查询到的数据是0条：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> check_in <span class="keyword">WHERE</span> user_id = <span class="number">1</span> <span class="keyword">AND</span> check_in_time &gt;= <span class="string">'2016-10-24 17:00:00'</span></span><br></pre></td></tr></table></figure>
<p>也就是说他可以签到，先尝试这样的数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br><span class="line">| user_id | check_in_date | check_in_time       |</span><br><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br><span class="line">| 1       | 2016-10-24    | 2016-10-24 16:00:01 |</span><br><span class="line">| 1       | 2016-10-24    | 2016-10-24 17:00:02 |</span><br><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>很明显，主键冲突了，第二条数据是写不进去的，那么此时就尝试<code>check_in_date</code>加一天：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br><span class="line">| user_id | check_in_date | check_in_time       |</span><br><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br><span class="line">| 1       | 2016-10-24    | 2016-10-24 16:00:01 |</span><br><span class="line">| 1       | 2016-10-25    | 2016-10-24 17:00:02 |</span><br><span class="line">+<span class="comment">---------+---------------+---------------------+</span></span><br></pre></td></tr></table></figure>
<p>再接下来，厉害了 Word 哥，他又改了时区：</p>
<p>用户强制修改自己的时区为<code>+600</code>，在当地时间<code>2016-10-25 00:02:03</code>签到，相当于在在 UTC 时间<code>2016-10-24 18:00:03</code>签到。</p>
<p>此时根据，“今天”他还是没有签到数据，但当他尝试插入<code>check_in_date = 2016-10-24</code>和<code>check_in_date = 2016-10-25</code>的时候都失败了！</p>
<p>至此，解决了用户换时区后多次签到的问题。</p>
<h3 id="如何高效地运算连续签到天数和今天是否已经签到"><a href="#如何高效地运算连续签到天数和今天是否已经签到" class="headerlink" title=" 如何高效地运算连续签到天数和今天是否已经签到 "></a><strong> 如何高效地运算连续签到天数和今天是否已经签到 </strong></h3><p>当我面临这个问题的时当我面临这个问题的时候，各种算法，数据结构浮现在我脑中。</p>
<p>  这种需求最先想到的就是二分查找发。</p>
<p>  查找的步骤大概是这样的：</p>
<p>  1.先搜索出某个人最近的10天的数据，大部分人不会连续签到这么久<br>  2.在内存中判断他是否连续签到了，他今天有没有签到<br>  3.如果这10的数据中有漏掉的天数，那么就可以直接返回他的连续签到天数和今天是否已经签到了<br>  4.如果他这10天全部签到了，那么就要开始查找以前的数据了，这时不需要找到所有数据，只要 COUNT 记录行数，对比一下天数就知道是否漏掉了<br>  5.先找20天前的数据，如果签到次数是20，那么继续找40天的数据，再找80天，以此类推。<br>  6.直到发现，例如160天的签到数据小于160，那么说明他的连续签到天数在80-160之间。<br>  7.二分查找发开始了，先判断120天的签到数据，如果是齐的，那么找120-160之前，一次类推最后会确认连续签到天数<br>  当这段代码跑起来的时候，我不经为自己鼓起了掌！👏👏👏👏👏</p>
<p>  然后，我还为此写了详细的注释：候，各种算法，数据结构浮现在我脑中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># check_offset_upper_bound = [</span><br><span class="line"># check_offset_lower_bound = ]</span><br><span class="line"># query_offset = ^</span><br><span class="line">#</span><br><span class="line"># Init status</span><br><span class="line">#               ^           ]</span><br><span class="line"># ?|?|?|?|?|?|?|?|?|?|?|?|?|*|*|*|*|*|*|</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># All check in</span><br><span class="line">#   ^           ]</span><br><span class="line"># ?|?|?|?|?|?|?|*|*|*|*|*|*|*|*|*|*|*|*|</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Not all check in</span><br><span class="line">#   [     ^     ]</span><br><span class="line"># x|x|?|?|?|?|?|*|*|*|*|*|*|*|*|*|*|*|*|</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># All check in</span><br><span class="line">#   [   ^ ]</span><br><span class="line"># x|x|?|?|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># All check in</span><br><span class="line">#   [ ^ ]</span><br><span class="line"># x|x|?|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Not all check in</span><br><span class="line">#     [ ]</span><br><span class="line"># x|x|x|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|</span><br></pre></td></tr></table></figure>
<p>感觉自己就要走向人生巅峰了！</p>
<h4 id="空间换时间"><a href="#空间换时间" class="headerlink" title=" 空间换时间 "></a><strong> 空间换时间 </strong></h4><p>正当我沾沾自喜的时候，还是感觉有点不太对劲，这段算法虽然高效，但是是否可以利用空间换时间，把这个数据存下来，再次提高效率呢？</p>
<p>最后，想到了最终版的高效方案。</p>
<h4 id="表结构"><a href="#表结构" class="headerlink" title=" 表结构 "></a><strong> 表结构 </strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">------------------------+------------------+------+-----+---------+-------+</span></span><br><span class="line">| Field                  | Type             | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">------------------------+------------------+------+-----+---------+-------+</span></span><br><span class="line">| user_id                | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| check_in_date          | timestamp        | NO   | PRI | NULL    |       |</span><br><span class="line">| check_in_time          | timestamp        | NO   |     | NULL    |       |</span><br><span class="line">| consecutive_check_days | int(10) unsigned | NO   |     | NULL    |       |</span><br><span class="line">+<span class="comment">------------------------+------------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure>
<h4 id="签到逻辑"><a href="#签到逻辑" class="headerlink" title=" 签到逻辑 "></a><strong> 签到逻辑 </strong></h4><p>假设数据库里有如下数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">---------+---------------+---------------------+-----------------------+</span></span><br><span class="line">| user_id | check_in_date | check_in_time       | consecutive_check_days|</span><br><span class="line">+<span class="comment">---------+---------------+---------------------+-----------------------+</span></span><br><span class="line">| 1       | 2016-10-24    | 2016-10-24 16:00:01 | 1                     |</span><br><span class="line">| 1       | 2016-10-25    | 2016-10-24 17:00:02 | 2                     |</span><br><span class="line">+<span class="comment">---------+---------------+---------------------+-----------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>假设现在是2016年10月26日，我需要查询今天是否可签到，和之前的连续签到天数。</p>
<p>查询语句是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> check_in <span class="keyword">WHERE</span> user_id = <span class="number">1</span> <span class="keyword">AND</span> check_in_date &gt;= <span class="string">'2016-10-25'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> check_in_date <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果一条数据都没，那么返回今天可签到，之前连续签到天数0</p>
<p>如果返回数据<code>check_in_time</code>是“今天”，并且<code>check_in_date</code>已经把之前提到的两个 UTC 日期坑位占满，那么今天就不可以签到了，但是之前的连续签到天数就是2。</p>
<p>相反，如果数据表示可以签到，那么这里就可以签到，签到逻辑和上面略有不同。</p>
<p>首先是多了<code>consecutive_check_days</code>，此时只要写入<code>2+1</code>即可。然后是根据查询到的数据，可以判断出 UTC 日期前一个坑位是否已经被占用，如果已经被占用，那么可以直接写入后一个坑位。</p>
<h4 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title=" 查询逻辑 "></a><strong> 查询逻辑 </strong></h4><p>查询逻辑其实就是刚才插入逻辑的一部分。利用索引高效查询，而且只要一条数据，就可以知道所有信息，非常高效！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title=" 总结 "></a><strong> 总结 </strong></h3><p>至此，一个简洁、高效、合理、无冲突的系统完成了。正是老司机的各种“怕”，造就了更安全的行车过程。</p>
<p>本作品由 <a href="dozer">Dozer</a> 创作，采用 <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用 4.0 国际许可协议</a> 进行许可。</p>
<hr>
<p style="margin-top: 0.4em; text-align: center"><br><b style="font-size: 1.5em;font-weight: 600;">未经授权，禁止转载</b><br> </p>


            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/转载/">转载</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/07/31/the-seventh-month-summary-in-2017/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">2017年第七月总结</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2017/07/03/the-nineteenth-week-summary-in-the-summer-of-2017/">
        <span class="next-text nav-default">2017年(夏)第十九周总结</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2000 -
    
    2018
    <span class="footer-author"><a href="https://github.com/cumtflyingstudio">flyingstudio</a>.</span>
    <span class="power-by">
         博客主题 <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
